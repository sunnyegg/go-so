// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: streams.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStream = `-- name: CreateStream :one
INSERT INTO streams
(
  user_id,
  title,
  game_name,
  started_at,
  created_by
)
VALUES
($1, $2, $3, $4, $5)
RETURNING id, user_id, title, game_name, started_at, created_at, created_by
`

type CreateStreamParams struct {
	UserID    int64              `json:"user_id"`
	Title     string             `json:"title"`
	GameName  string             `json:"game_name"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
	CreatedBy int64              `json:"created_by"`
}

func (q *Queries) CreateStream(ctx context.Context, arg CreateStreamParams) (Stream, error) {
	row := q.db.QueryRow(ctx, createStream,
		arg.UserID,
		arg.Title,
		arg.GameName,
		arg.StartedAt,
		arg.CreatedBy,
	)
	var i Stream
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.GameName,
		&i.StartedAt,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteStream = `-- name: DeleteStream :exec
DELETE FROM streams
WHERE id = $1
`

func (q *Queries) DeleteStream(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteStream, id)
	return err
}

const getStream = `-- name: GetStream :one
SELECT s.title, s.game_name, s.started_at, u.user_name as created_by_username
FROM streams s JOIN users u ON s.user_id = u.id
WHERE s.id = $1
  AND s.user_id = $2
LIMIT 1
`

type GetStreamParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

type GetStreamRow struct {
	Title             string             `json:"title"`
	GameName          string             `json:"game_name"`
	StartedAt         pgtype.Timestamptz `json:"started_at"`
	CreatedByUsername string             `json:"created_by_username"`
}

func (q *Queries) GetStream(ctx context.Context, arg GetStreamParams) (GetStreamRow, error) {
	row := q.db.QueryRow(ctx, getStream, arg.ID, arg.UserID)
	var i GetStreamRow
	err := row.Scan(
		&i.Title,
		&i.GameName,
		&i.StartedAt,
		&i.CreatedByUsername,
	)
	return i, err
}

const getStreamAttendanceMembers = `-- name: GetStreamAttendanceMembers :many
SELECT s.title, s.game_name, s.started_at, am.username, am.is_shouted, am.present_at
FROM attendance_members as am JOIN streams as s ON am.stream_id = s.id
WHERE am.stream_id = $3 AND s.user_id = $4
ORDER BY am.present_at ASC
LIMIT $1
OFFSET $2
`

type GetStreamAttendanceMembersParams struct {
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
	StreamID int64 `json:"stream_id"`
	UserID   int64 `json:"user_id"`
}

type GetStreamAttendanceMembersRow struct {
	Title     string             `json:"title"`
	GameName  string             `json:"game_name"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
	Username  string             `json:"username"`
	IsShouted bool               `json:"is_shouted"`
	PresentAt pgtype.Timestamptz `json:"present_at"`
}

func (q *Queries) GetStreamAttendanceMembers(ctx context.Context, arg GetStreamAttendanceMembersParams) ([]GetStreamAttendanceMembersRow, error) {
	rows, err := q.db.Query(ctx, getStreamAttendanceMembers,
		arg.Limit,
		arg.Offset,
		arg.StreamID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStreamAttendanceMembersRow{}
	for rows.Next() {
		var i GetStreamAttendanceMembersRow
		if err := rows.Scan(
			&i.Title,
			&i.GameName,
			&i.StartedAt,
			&i.Username,
			&i.IsShouted,
			&i.PresentAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStreams = `-- name: ListStreams :many
SELECT s.title, s.game_name, s.started_at, u.user_name as created_by_username
FROM streams s JOIN users u ON s.user_id = u.id
WHERE s.user_id = $3
ORDER BY s.started_at DESC
LIMIT $1
OFFSET $2
`

type ListStreamsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
	UserID int64 `json:"user_id"`
}

type ListStreamsRow struct {
	Title             string             `json:"title"`
	GameName          string             `json:"game_name"`
	StartedAt         pgtype.Timestamptz `json:"started_at"`
	CreatedByUsername string             `json:"created_by_username"`
}

func (q *Queries) ListStreams(ctx context.Context, arg ListStreamsParams) ([]ListStreamsRow, error) {
	rows, err := q.db.Query(ctx, listStreams, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStreamsRow{}
	for rows.Next() {
		var i ListStreamsRow
		if err := rows.Scan(
			&i.Title,
			&i.GameName,
			&i.StartedAt,
			&i.CreatedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
